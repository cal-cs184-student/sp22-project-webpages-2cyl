<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      padding: 60px;
      width: 800px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-size: small;
      font-family: 'Roboto Mono';
      color: #d9dfd7;
      background-color: #41443d;
      text-align: justify;
      text-justify: inter-word;
    }

    h1 {
      font-size: x-large;
    }

    h2 {
      font-size: large;
      color: #b395c5;
    }

    h3 {
      font-size: medium;
      color: #b395c5;
    }

    h4 {
      font-size: small;
    }

    code {
      font-size: medium;
      display: inline-block;
      background: #2b2e28;
    }

    a {
      color: #d9dfd7;
    }

    /* width */
    ::-webkit-scrollbar {
      width: 8px;
    }

    /* Track */
    ::-webkit-scrollbar-track {
      background: #d9dfd7;
    }

    /* Handle */
    ::-webkit-scrollbar-thumb {
      background: #41443d;
    }

    /* Handle on hover */
    ::-webkit-scrollbar-thumb:hover {
      background: #41443d;
    }
  </style>
  <title>CS 184 MeshEdit: Clare Lin, Faywer Liu</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">

  <!-- mathjax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>


<body>

  <h1 align="middle">CS 184: Computer Graphics and Imaging [SP22]</h1>
  <h1 align="middle">Project 2: MeshEdit</h1>
  <h2 align="middle">Clare Lin, Faywer Liu</h2>
  <br><br><img src="images/147nmya.png" width="800px" class="center">

  <div>

    <br><br>
    <h2 align="middle">Overview</h2>
    <p> something about bezier de castalaisd algorithm

      <br><br>
      Overall, this was a fun project and we enjoyed learning about mesh editing and were surprised by how complex
      it is just to display many meshes on our screens.
    </p>

    <br>
    <h2 align="middle">Section I: Bezier Curves and Surfaces</h2>
    <h3 align="middle">Task 1: Bezier Curves with 1D de Casteljau Subdivision</h3>

    <p> We implemented de Casteljau's algorithm for Bezier curves by recursively solving for the control points of
      the curve at each subdivision level. We then used the control points to draw the curve. At each recursion step, we
      lerp'ed between every two points in the current points vector to get the new control points until there was only
      one point left. The lerp function is as follows, where /(t/) is the tuning parameter, a and b are the two points
      to
      lerp between.

      $$lerp(t, a, b) = a + t * (b - a)$$

    <div align="middle">
      <br><br><img src="images/task1-1.gif" align="middle" width="400px">
      <figcaption align="middle">Progression of recursive control point calculations</figcaption>
    </div>

    <div align="middle">
      <br><br><img src="images/task1-2.gif" align="middle" width="400px">
      <figcaption align="middle">Evaluated point moving along Bezier curve</figcaption>
    </div>
    
    <div align="middle">
      <br><br><img src="images/dragging.gif" align="middle" width="400px">
      <figcaption align="middle">Dragging control point</figcaption>
    </div>
    
  </div>

  <div align>
    <br><br>
    <h3 align="middle">Task 2: Bezier Surfaces with Separable 1D de Casteljau</h3>

    <p>We now extend the de Castelijau algorithm from evaluating Bezier curves to evaluating Bezier surfaces. The
      algorithm was changed from performing lerps with control points in the 2D space to the 3D space. The logic of the
      algorithm mostly remains the same.
    </p>
    <div align="middle">
      <br><br><img src="images/teapot.png" align="middle" width="600px">
      <figcaption align="middle">The teapot with Bezier surfaces</figcaption>
    </div>

    <br><br>
    <h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>
    <h3 align="middle">Task 3: Area-Weighted Vertex Normals</h3>
    <p>
      We implemented area-weighted vertex normals for Phong shading, improving on smoothness of surfaces from the flat
      shading method. To achieve this, we first used the halfedge data structure to traverse the neighbor vertices of a
      center vertex. Two edges were found through the difference between the center vertex and two neighbor vertices.
      Then we
      used the cross product of the two edges to calculate each normal, and summed up all the normals. Lastly we
      returned the approximate unit normal at that vertex to obtain Phong shading.
    </p>
    <div align="middle">
      <br><br> <img src="images/notsmooth.png" align="middle" width="600px">
      <figcaption align="middle">Flat shaded teapot</figcaption>
    </div>
    <div align="middle">
      <br><br> <img src="images/smooth.png" align="middle" width="600px">
      <figcaption align="middle">Phong shaded teapot</figcaption>
    </div>

    <br><br>
    <h3 align="middle">Task 4: Edge Flip</h3>
    <p> We have a thorough edge flip implementation that can use used to flip any edge in the mesh. We first assign
      variable names to all the halfedges, edges, vertices, and faces in the given configuration. Then we reassign all
      properties to the halfedges using the <code>Halfedge::setNeighbors(...)</code> function. After that we keep
      reassigning all the other edges, vertices, and faces to have the correct correspopnding halfedge.
    </p>

    <p> An interesting but frustrating problem we had was that the UI window was freezing up due to coding error when an
      edge flip was attempted, so it was hard to debug through the UI. However, finally when the UI stopped freezing all
      was working well. Seeing the frozen window led us to being safe and setting every variable, even if it might not
      have been all needed, to make sure no holes were found. Another mistake was wrongly assuming that some halfedges
      belonged in the two faces shown in the diagram, as well as wrongly assuming the next halfedge properties for some
      halfedges. This was realized thanks to browsing a comment on Piazza.</p>

    <div align="middle">
      <br><br> <img src="images/edge_flip_diagram.png" align="middle" width="800px">
      <figcaption align="middle">Helpful edge flip diagram</figcaption>
    </div>

    <br><br>
    <h3 align="middle">Task 5: Edge Split</h3>
    <p>Pixel sampling is mapping pixels from one image to another (can be differing sizes).</p>
    <p>We implemented pixel sampling for texture mapping by taking the color at the (u, v)
      coordinate in our texture map and mapping it to the (x, y) coordinate in our screen space.
      The two sampling methods we implemented are nearest sampling and bilinear sampling.</p>
    <p>Nearest sampling simply outputs the color of the nearest pixel. This is done by rounding the (u, v) coordinate.
    </p>
    <p>Bilinear sampling takes the 4 nearest sample locations and returns a weighted average color based on location.
      This is
      done through linear interpolation vertically, horizontally, and finally between the previous results.</p>

    <div align="middle">
      <br><br>
      <table style="width=100%">
        <tbody>
          <tr>
            <td>
              <img src="images/task5-near-1.png" align="middle" width="400px">
              <figcaption align="middle">Nearest Sampling, 1 Sample Per Pixel</figcaption>
            </td>
            <td>
              <img src="images/task5-near-16.png" align="middle" width="400px">
              <figcaption align="middle">Nearest Sampling, 16 Samples Per Pixel</figcaption>
            </td>
          </tr>

          <tr>
            <td>
              <img src="images/task5-linear-1.png" align="middle" width="400px">
              <figcaption align="middle">Bilinear Sampling, 1 Sample Per Pixel</figcaption>
            </td>
            <td>
              <img src="images/task5-linear-16.png" align="middle" width="400px">
              <figcaption align="middle">Bilinear Sampling, 16 Samples Per Pixel</figcaption>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <p>
      <br>
      We observed some differences between the two sampling methods. Bilinear sampling tends to give a blurrier result
      due to averaging out values, which we can see in the images above. Nearest sampling only clips to the closest
      color for a pixel result, which results in sharper edges in the images, but also more jaggies. In terms of
      computation, bilinear will be more costly. This is especially true when computing images of large dimension for
      bilinear sampling, since we are sampling four times as many locations, and also performing three lerps to obtain a
      weighted average final result.
    </p>
    <p>
      On images with lower resolution, there will be large differences since nearest ignores surrounding pixels with an
      already low sample size.
      On images with larger resolutions, these differences are less noticeable since averages become less useful with
      larger sample sizes.
    </p>

    <br>
    <h3 align="middle">Task 6: Loop Subdivision for Mesh Upsampling</h3>
    <p>A mipmap is a data structure containing images in which each is a lower resolution (usually ½ the height and
      width) of the previous image. In this application, we store a texture in our mipmap. Level sampling is simply
      sampling from a “level” of a mipmap. As discussed in lecture we can choose a good
      mipmap level with the following formula.

      $$L = max(\sqrt{(\frac {du}{dx})^2 + \frac{dv}{dx})^2}, \sqrt{(\frac {du}{dy})^2 + \frac{dv}{dy})^2})$$
      $$D = \log_2(L)$$

    <p>
      Our implementation allows us to sample from level 0, the nearest level found by the formula, and a
      weighted average of adjacent levels found by the formula.
    </p>

    <br><br>
    <div align="middle">
      <table style="width=100%">
        <tbody>
          <tr>
            <td>
              <img src="images/l0pn.png" align="middle" width="400px">
              <figcaption align="middle">L_ZERO and P_NEAREST</figcaption>
            </td>
            <td>
              <img src="images/l0pl.png" align="middle" width="400px">
              <figcaption align="middle">L_ZERO and P_LINEAR</figcaption>
            </td>
          </tr>

          <tr>
            <td>
              <img src="images/lnpn.png" align="middle" width="400px">
              <figcaption align="middle">L_NEAREST and P_NEAREST</figcaption>
            </td>
            <td>
              <img src="images/lnpl.png" align="middle" width="400px">
              <figcaption align="middle">L_NEAREST and P_LINEAR</figcaption>
            </td>
          </tr>

        </tbody>
      </table>

    </div>
</body>
<br>
<p>
  From our image comparison, we think L_NEAREST and P_LINEAR gives the best results. This is expected as it is almost
  trilinear filtering.
</p>
<p>Supersampling had powerful antialiasing results, but we found that at high sample rates, the images feel too smooth
  and blurred out sometimes. Supersampling uses the most memory and also is the slowest.</p>

<p>Level sampling with a mip map has more subtle antialiasing results. It requires 4/3 times the amount of memory and
  was slower than pixel sampling.</p>

<p>Pixel sampling had great antialiasing results. It requires the least amount of memory and also performed the
  quickest.</p>

<p>We thought that pixel sampling gave the best tradeoffs between antialiasing and memory/speed.</p>

<br><br>
<h3 align="middle">Task 7: Design and Edit Your Own Mesh!</h3>
<p>To create this image, we fed a png into <a href=https://www.samcodes.co.uk/project/geometrize-haxe-web/
    target="_blank">Geometrize</a> which converts our png into a svg composed of triangles.
  However,
  the svgparser included in this project only supports colors given in hex while Geometrize outputs colors in the format
  "rgb(r,g,b)" so we had to edit it in <code>svgparser.cpp</code> to allow support for this format.
</p>

<div align="middle">
  <br><br><img src="images/competition.png" align="middle" width="800px">
  <figcaption align="middle">Buff Kirby</figcaption>
</div>

</html>
