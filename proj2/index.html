<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      padding: 60px;
      width: 800px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-size: small;
      font-family: 'Roboto Mono';
      color: #d9dfd7;
      background-color: #41443d;
      text-align: justify;
      text-justify: inter-word;
    }

    h1 {
      font-size: x-large;
    }

    h2 {
      font-size: large;
      color: #b395c5;
    }

    h3 {
      font-size: medium;
      color: #b395c5;
    }

    h4 {
      font-size: small;
    }

    code {
      font-size: medium;
      display: inline-block;
      background: #2b2e28;
    }

    a {
      color: #d9dfd7;
    }

    /* width */
    ::-webkit-scrollbar {
      width: 8px;
    }

    /* Track */
    ::-webkit-scrollbar-track {
      background: #d9dfd7;
    }

    /* Handle */
    ::-webkit-scrollbar-thumb {
      background: #41443d;
    }

    /* Handle on hover */
    ::-webkit-scrollbar-thumb:hover {
      background: #41443d;
    }
  </style>
  <title>CS 184 MeshEdit: Clare Lin, Faywer Liu</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">

  <!-- mathjax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>


<body>

  <h1 align="middle">CS 184: Computer Graphics and Imaging [SP22]</h1>
  <h1 align="middle">Project 2: MeshEdit</h1>
  <h2 align="middle">Clare Lin, Faywer Liu</h2>
  <br><br><img src="images/147nmya.png" width="800px" class="center">

  <div>

    <br><br>
    <h2 align="middle">Overview</h2>
    <p> something about bezier de castalaisd algorithm

      <br><br>
      Overall, this was a fun project and we enjoyed learning about mesh editing and were surprised by how complex
      it is just to display many meshes on our screens.
    </p>

    <br>
    <h2 align="middle">Section I: Bezier Curves and Surfaces</h2>
    <h3 align="middle">Task 1: Bezier Curves with 1D de Casteljau Subdivision</h3>

    <p> We implemented de Casteljau's algorithm for Bezier curves by recursively solving for the control points of
      the curve at each subdivision level. We then used the control points to draw the curve. At each recursion step, we
      lerp'ed between every two points in the current points vector to get the new control points until there was only
      one point left. The lerp function is as follows, where /(t/) is the tuning parameter, a and b are the two points
      to
      lerp between.

      $$lerp(t, a, b) = a + t * (b - a)$$

    <div align="middle">
      <br><br><img src="images/task1-1.gif" align="middle" width="400px">
      <figcaption align="middle">Progression of recursive control point calculations</figcaption>
    </div>

    <div align="middle">
      <br><br><img src="images/task1-2.gif" align="middle" width="400px">
      <figcaption align="middle">Evaluated point moving along Bezier curve</figcaption>
    </div>
    
    <div align="middle">
      <br><br><img src="images/dragging.gif" align="middle" width="400px">
      <figcaption align="middle">Dragging control point</figcaption>
    </div>
    
  </div>

  <div align>
    <br><br>
    <h3 align="middle">Task 2: Bezier Surfaces with Separable 1D de Casteljau</h3>

    <p>We now extend the de Castelijau algorithm from evaluating Bezier curves to evaluating Bezier surfaces. The
      algorithm was changed from performing lerps with control points in the 2D space to the 3D space. The logic of the
      algorithm mostly remains the same.
    </p>
    <div align="middle">
      <br><br><img src="images/teapot.png" align="middle" width="600px">
      <figcaption align="middle">The teapot with Bezier surfaces</figcaption>
    </div>

    <br><br>
    <h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>
    <h3 align="middle">Task 3: Area-Weighted Vertex Normals</h3>
    <p>
      We implemented area-weighted vertex normals for Phong shading, improving on smoothness of surfaces from the flat
      shading method. To achieve this, we first used the halfedge data structure to traverse the neighbor vertices of a
      center vertex. Two edges were found through the difference between the center vertex and two neighbor vertices.
      Then we
      used the cross product of the two edges to calculate each normal, and summed up all the normals. Lastly we
      returned the approximate unit normal at that vertex to obtain Phong shading.
    </p>
    <div align="middle">
      <br><br> <img src="images/notsmooth.png" align="middle" width="600px">
      <figcaption align="middle">Flat shaded teapot</figcaption>
    </div>
    <div align="middle">
      <br><br> <img src="images/smooth.png" align="middle" width="600px">
      <figcaption align="middle">Phong shaded teapot</figcaption>
    </div>

    <br><br>
    <h3 align="middle">Task 4: Edge Flip</h3>
    <p> We have a thorough edge flip implementation that can use used to flip any edge in the mesh as long as it is not a boundary edge. 
      We first assign variable names to all the halfedges, edges, vertices, and faces in the given configuration. Then we reassign all
      properties to the halfedges using the <code>Halfedge::setNeighbors(...)</code> function. After that we keep
      reassigning all the other edges, vertices, and faces to have the correct correspopnding halfedge. Our assignments are based on
      the figure below.
    </p>

    <div align="middle">
      <br><br> <img src="images/edge_flip_diagram.png" align="middle" width="800px">
      <figcaption align="middle">Helpful edge flip diagram</figcaption>
    </div>

    <p> An interesting but frustrating problem we had was that the UI window was freezing up due to coding error when an
      edge flip was attempted, so it was hard to debug through the UI. However, finally when the UI stopped freezing all
      was working well. Seeing the frozen window led us to being safe and setting every variable, even if it might not
      have been all needed, to make sure no holes were found. Another mistake was wrongly assuming that some halfedges
      belonged in the two faces shown in the diagram, as well as wrongly assuming the next halfedge properties for some
      halfedges. This was realized thanks to browsing a comment on Piazza.</p>

    

    <br><br>

    <h3 align="middle">Task 5: Edge Split</h3>
    <p> We have a thorough edge split implementation that can use used to split any edge in the mesh as long as it is not a boundary edge. 
      It's implementation is quite similar to edge flipping. We first assign variable names to all the halfedges, edges, vertices, and faces 
      in the given configuration; however, we have to create three new edges, sixteen halfedges, two faces, and an extra vertex. Then we reassign all
      properties to the halfedges using the <code>Halfedge::setNeighbors(...)</code> function. After that we keep
      reassigning all the other edges, vertices, and faces to have the correct correspopnding halfedge.Our assignments are based on
      the figure below.
    </p>

    <div align="middle">
      <br><br> <img src="images/split_diagram.png" align="middle" width="800px">
      <figcaption align="middle">Helpful edge split diagram</figcaption>
    </div>

    <p> Again, we had issues with the UI freezing after incorrectly assigning pointer values. This was fixed by careful review of the diagram.
        Another issue we had is that we used 2 different "starting" diagrams while our initial pointer assignments stayed this same. This caused
        some holes in our tea pot.
    </p>

    <br><br>
    <div align="middle">
      <table style="width=100%">
        <tbody>
          <tr>
            <td>
              <img src="images/pre_split.png" align="middle" width="400px">
              <figcaption align="middle">Teapot before splitting</figcaption>
            </td>
            <td>
              <img src="images/post_split.png" align="middle" width="400px">
              <figcaption align="middle">Teapot after splitting</figcaption>
            </td>
          </tr>
        </tbody>
      </table>
         
      <br><br>
      <div align="middle">
        <table style="width=100%">
          <tbody>
      <tr>
        <td>
          <img src="images/pre_combo.png" align="middle" width="400px">
          <figcaption align="middle">Teapot before a combo of flip/split</figcaption>
        </td>
        <td>
          <img src="images/post_combo.png" align="middle" width="400px">
          <figcaption align="middle">Teapot after a combo of flip/split</figcaption>
        </td>
      </tr>
    </tbody>
  </table>


    </div>
</body>
<br>

    <br><br>
    <h3 align="middle">Task 6: Loop Subdivision for Mesh Upsampling</h3>
    
    <p>
      Our implementation of loop subdivision heavily follows the hints given. In the first step, we update vertex positions using a weighted average of neighboring vertices.
      For old vertices, we iterate through each vertex and calculate the new position. We also make sure to mark each vertex as old. For new vertices, we calculate
      the position of where a vertex will be formed by iterating through all the edges and computing a weighted average. Next, we split each non-boundary edge. However,
      to avoid an infinite loop, we have to first copy each edge into a queue and iterate through that. We mark these vertices as new and also assign them their new position found earlier.
      Next we flip any new edge that connects an old vertex and a new vertex. Finally, we iterate through each vertex and set their position to their new position.
    </p>
  

    <br><br>
    <div align="middle">
      <table style="width=100%">
        <tbody>
          <tr>
            <td>
              <img src="images/cube0.png" align="middle" width="400px">
              <figcaption align="middle">Cube Level 0 Subdivision</figcaption>
            </td>
            <td>
              <img src="images/cube1.png" align="middle" width="400px">
              <figcaption align="middle">Cube Level 1 Subdivision</figcaption>
            </td>
          </tr>

          <tr>
            <td>
              <img src="images/cube2.png" align="middle" width="400px">
              <figcaption align="middle">Cube Level 2 Subdivision</figcaption>
            </td>
            <td>
              <img src="images/cube3.png" align="middle" width="400px">
              <figcaption align="middle">Cube Level 3 Subdivision</figcaption>
            </td>
          </tr>

        </tbody>
      </table>

    </div>

    <br><br>

    <div align="middle">
      <table style="width=100%">
        <tbody>
          <tr>
            <td>
              <img src="images/presplitcube0.png" align="middle" width="400px">
              <figcaption align="middle">Pre-Split Cube Level 0 Subdivision</figcaption>
            </td>
            <td>
              <img src="images/presplitcube1.png" align="middle" width="400px">
              <figcaption align="middle">Pre-Split Cube Level 1 Subdivision</figcaption>
            </td>
          </tr>

          <tr>
            <td>
              <img src="images/preslitcube2.png" align="middle" width="400px">
              <figcaption align="middle">Pre-Split Cube Level 2 Subdivision</figcaption>
            </td>
            <td>
              <img src="images/presplitcube3.png" align="middle" width="400px">
              <figcaption align="middle">Pre-Split Cube Level 3 Subdivision</figcaption>
            </td>
          </tr>

        </tbody>
      </table>

    </div>
</body>
<br>


</html>
